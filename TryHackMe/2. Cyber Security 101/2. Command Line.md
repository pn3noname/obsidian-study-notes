source: https://tryhackme.com/room/windowscommandline

---

## 1. Windows Command Line

1. Basic System Information
	1. `set`
		- MS Windows가 명령어를 실행할 경로 (`Path=`로 시작하는 줄)
			![[Pasted image 20250712142342.png]]

	2. `ver` -> Mac: `sw_vers`
		- 운영 체제 (OS) 버전 확인
			![[Pasted image 20250712144839.png]]

	3. `systeminfo` -> Mac: `system_profiler`
			![[Pasted image 20250712145003.png]]
		- OS 정보, 시스템 세부사항, 프로세서 및 메모리 등 시스템에 대한 다양한 정보

	4. `driverquery | more`
			![[Pasted image 20250712145540.png]]
		- 출력이 너무 길 경우 `more`를 통해 파이프할 수 있음 (스페이스바 버튼을 눌러 페이지별로 볼 수 있음)

2. Network Troubleshooting
	1. Network Configuration (네트워크 구성)
		- `ipconfig`를 사용하여 네트워크 정보를 확인할 수 있음 -> Mac: `ifconfig`
		- `ipconfig /all`을 사용하여 네트워크 구성에 대한 더 자세한 정보를 볼 수 있음 (DNS 서버를 확인하고 DHCP가 활성화되어 있는지 확인 가능)
			![[Pasted image 20250712174252.png]]
		- Which command can we use to look up the server’s physical address (MAC address)? -> ipconfig /all

	2. Network Troubleshooting
		1. `ping target_name`
			- 일반적인 문제 해결 작업 중 하나는 서버가 인터넷상의 특정 서버에 접근할 수 있는지 확인하는 것
			- ex: `ping example.com`
			- 특정 ICMP 패킷을 보내고 응답을 기다리며, 응답이 수신되면 대상에 도달할 수 있고, 대상도 우리에게 도달할 수 있다는 것을 알 수 있음

		2. `tracert target_name` -> Mac: `traceroute target_name`
			- trace route의 줄임말
			- ex: `tracert google.com`
			- 대상에 도달하기 위해 경유하는 네트워크 경로를 추적함
			- 경로상의 라우터들이 패킷의 TTL (Time-To-Live)이 0에 도달하여 패킷을 폐기할 때 우리에게 알려주기를 기대함
			- 명령어 입력 후, 터미널 출력에서는 목표에 도달하기 전에 n개의 라우터를 통과했음을 보여줌
				![[Pasted image 20250712175923.png]]

	3. More Networking Commands
		1. `nslookup `
			- 호스트나 도메인을 조회하여 IP주소를 반환함
			- `nslookup example.com`: 기본 네임 서버를 사용하여 example.com을 조회
			- `nslookup example.com 1.1.1.1`: 1.1.1.1 네임 서버를 사용함
				![[Pasted image 20250712180255.png]]

		2. `netstat`
			- 현재 네트워크 연결과 수신 대기 중인 포트를 표시함
			- 인수 없이 사용하는 기본 `netstat`
				![[Pasted image 20250713141123.png]]
			- 위의 예의 경우, SSH 연결이 하나만 있으며, 포트 22에 바인딩되어 있어 SSH임을 알 수 있음
			- 다른 옵션들:
				- `netstat -h`: 도움말 페이지
				- `netstat -a`: 모든 설정된 연결과 수신 대기 중인 포트 표시
				- `netstat -b`: 각 수신 대기 포트 및 설정된 연결과 연관된 프로그램을 표시
				- `netstat -o`: 연결과 연관된 프로세스 ID (PID)를 표시
				- `netstat -n`: 주소와 포트 번호에 대해 숫자 형식을 사용
			- ex:
				![[Pasted image 20250713141752.png]]
				- 위의 예의 첫 번째 줄에서 보여주는 것처럼 실팽 파일 `sshd.exe`가 포트 22에서 들어오는 연결을 수신 대기하는 역할을 담당
				- 각 연결과 연관된 프로세스 ID (PID)도 확인 가능

> [!INFO]
> ### DHCP (Dynamic Host Configuration Protocol)
> - 네트워크에 연결된 장치들에게 자동으로 IP 주소와 네트워크 설정을 배정해주는 프로토콜
> #### 1.DHCP의 역할
> - 자동 IP 주소 할당: 컴퓨터, 스마트폰, 태블릿 등이 네트워크에 연결될 때 자동으로 사용 가능한 IP 주소를 찾아서 할당해 줌
> - 네트워크 설정 제공: IP 주소 외에도 서브넷 마스크, 게이트웨이 주소, DNS 서버 주소 등 네트워크에 접속하기 위해 필요한 모든 정보를 함께 제공함
> - IP 주소 관리: 사용하지 않는 IP 주소를 회수하고 재사용할 수 있도록 관리함
> #### 2. 쉬운 비유
> - DHCP를 호텔의 프런트 데스크에 비유할 수 있음. 손님(장치)이 호텔(네트워크)에 도착하면, 프런트 데스크 직원(DHCP 서버)이 빈 방(IP 주소)을 찾아서 열쇠와 함께 호텔 이용 안내서(네트워크 설정)를 제공해줌. 손님이 체크아웃하면 그 방은 다시 다른 손님이 사용할 수 있게 됨
> #### 3. DHCP가 없다면?
> - DHCP가 없다면 네트워크 관리자가 모든 장치에 수동으로 IP 주소를 설정해야 하고, IP 주소 충돌을 방지하기 위해 어떤 주소가 사용 중인지 계속 추적함 (이는 매우 번거롭고 실수가 발생하기 쉬운 작업)
> - 일반적으로 가정용 공유기나 회사의 네트워크 장비에 DHCP 서버 기능이 내장되어 있어서, 우리가 와이파이에 연결할 때 자동으로 인터넷을 사용할 수 있는 것

> [!INFO]
> ### ICMP (Internet Control Message Protocol)
> - 네트워크에서 오류나 상태 정보를 전달하는 프로토콜
> #### 1. ICMP의 기본 개념
> - ICMP는 IP 프로토콜의 보조 역할을 하는 프로토콜
> - 데이터 전송 자체보다는 네트워크 상태를 점검하고 문제를 알려주는 역할을 함
> - 마치 우편 시스템에서 "배달 불가" 스티커를 붙여 돌려보내는 것과 비슷함
> #### 2. 주요 역할
> - 오류 메시지 전달: 패킷이 목적지에 도달할 수 없거나, 전송 중 문제가 생겼을 때 송신자에게 알려줌. 예를 들어 "목적지에 도달할 수 없음", "시간 초과", "포트가 닫혀있음" 같은 정보를 전달
> - 네트워크 진단: ping 명령어가 대표적인 예시. ping은 ICMP Echo Request를 보내고 Echo Reply를 받아서 네트워크 연결 상태와 응답 시간을 확인함
> - 경로 추적: traceroute 명령어에서 사용되어 패킷이 목적지까지 어떤 경로를 거쳐가는지 확인할 수 있음
> #### 3. 실생활 비유
> - ICMP를 우편 시스템에 비유하면, 편지(데이터 패킷)를 보낼 때 우체국(라우터)에서 "주소 불명으로 배달 불가", "수신인 부재" 같은 메모를 붙여 돌려보내는 것과 같음
> - 또한 "잘 도착했는지 확인해줘"라고 요청하면 "잘 받았어"라고 답장을 보내주는 역할도 함
> - ICMP는 네트워크 관리자가 네트워크 문제를 진단하고 해결하는 데 필수적인 도구이며, 일반 사용자도 인터넷 연결 상태를 확인할 때 간접적으로 사용하게 됨

3. File and Disk Management
	1. Working with Directories
		- 매개변수 없이 `cd` 명령을 사용하여 현재 드라이브와 디렉토리 표시할 수 있음
		- `dir` 명령을 사용하여 하위 디렉토리를 볼 수 있음
			![[Pasted image 20250713232927.png]]
		- `dir` 명령에서 사용할 수 있는 옵션들:
			- `dir /a`: 숨겨진 파일과 시스템 파일도 표시
			- `dir /s`: 현재 디렉토리와 모든 하위 디렉토리의 파일을 표시
		- `tree` 명령을 입력하여 하위 디렉토리와 서브디렉토리를 시각적으로 표현할 수 있음
			![[Pasted image 20250713233135.png]]
		- `rmdir directory_name`: 디렉토리 삭제
			![[Pasted image 20250713233326.png]]

	2. Working with Files
		- `type`: 명령줄로 작업할 때 특정 텍스트 파일의 내용을 확인할 수 있음 (더 긴 텍스트 파일의 경우 `more` 명령)
		- `copy`: 파일을 한 위치에서 다른 위치로 복사할 수 있음
			![[Pasted image 20250713233642.png]]
		- `move`: 파일 이동
			![[Pasted image 20250713233758.png]]
		- `del` or `erase`: 파일 삭제
		- `*` (와일드카드 문자): 여러 파일을 참조할 수 있음
			- ex: `copy *.md C:\Markdown` -> 확장자가 md인 모든 파일을 C:\Markdown 디렉토리로 복사

4. Task and Process Management
	1. 실행 중인 프로세스 목록 확인
		- `tasklist`: 실행 중인 프로세스 나열
			![[Pasted image 20250713235006.png]]

	2. 프로세스 필터링
		- 위의 예와 같이 출력이 매우 길 것으로 예상될 땐 필터링이 유용함
		- `tasklist /?`: 도움말 페이지를 표시하면 사용 가능한 모든 필터 확인 가능
		- ex: `sshd.exe`와 관련된 작업 검색 -> `tasklist /FI "imagename eq sshd.exe`
			- `/FI`: 필터를 설정하는 데 사용됨
			![[Pasted image 20250713235347.png]]

	3. 프로세스 종료
		- 프로세스 ID (PID)를 알면 명령어를 사용하여 작업 종료 가능
		- `taskkill /PID target_pid`
		- ex: `taskkill /PID 4567`

> [!TIP]
> ### 추가적인 명령어
> - `chkdsk`: 파일 시스템과 디스크 볼륨의 오류 및 배드 섹터를 검사
> - `driverquery`: 설치된 장치 드라이버 목록 표시
> - `sfc /scnanow`: 시스템 파일의 손상을 스캔하고 가능한 경우 복구
> - `shutdown /r`: The command `shutdown /s` can shut down a system. What is the command you can use to restart a system?
> - `shutdown /a`: What command can you use to abort a scheduled system shutdown?

---

## 2. Windows PowerShell

1. PowerShell이란?
	- PowerShell은 작업 자동화와 구성 관리를 위해 Microsoft에서 개발한 강력한 도구
	- `.NET framework`를 기반으로 구축된 명령줄 인터페이스와 스크립팅 언어를 결합한 것
	- 기존의 텍스트 기반 명령줄 도구들과 달리, PowerShell을 객체 지향적이어서 복잡한 데이터 유형을 처리하고 시스템 구성 요소와 더 효과적으로 상호작용할 수 있음
	- 처음에는 Windows 전용이었지만, 최근 macOS와 Linux를 지원하도록 확장됨

2. PowerShell의 간략한 역사
	- PowerShell은 Windows에서 기존 명령줄 도구와 스크립팅 환경의 한계를 극복하기 위해 개발됨
	- 2000년대 초, Windows가 복잡한 기업 환경에서 점점 더 많이 사용되면서, `cmd.exe`와 배치 파일 같은 전통적인 도구들은 이러한 시스템을 자동화하고 관리하는 데 한계를 드러냄
	- Microsoft는 더 정교한 관리 작업을 처리하고 Windows의 현대적인 API와 상호작용할 수 있는 도구가 필요했음
	- Microsoft 엔지니어인 Jeffrey Snover는 Windows와 Unix가 시스템 운영을 다르게 처리한다는 것을 깨달음
	- Windows는 구조화된 데이터와 API를 사용하는 반면, Unix는 모든 것을 텍스트 파일로 처리
	- 이러한 차이점으로 인해 Unix 도구를 Windows에 이식하는 것이 비실용적이었음
	- Snover의 해결책은 스크립팅의 단순함과 .NET 프레임워크의 강력함을 결합한 `object-oriented approach (객체 지향적 접근 방식)`을 개발하는 것이었음
	- 2006년에 출시된 PowerShell은 관리자들이 객체를 조작하여 작업을 더 효과적으로 자동화할 수 있게 해주었으며, Windows 시스템과의 더 깊은 통합을 제공했음

3. PowerShell의 힘
	- 이에 대해 완전히 이해하려면, 먼저 이 맥락에서 `object (객체)`가 무엇인지 이해해야 함
	- 프로그래밍에서 **객체**는 `properties (characteristics); 속성 (특성)`과 `methods; 메서드 (동작)를 가진 항목을 나타냄
	- ex: `자동차` 객체는 `색상`, `모델`, `연료량`과 같은 속성을 가질 수 있고, `운전하기()`, `경적울리기()`, `급유하기()`와 같은 메서드를 가질 수 있음
	- 마찬가지로, PowerShell에서 객체는 데이터와 기능을 캡슐화하는 기본 단위로, 정보를 관리하고 조작하는 것을 더 쉽게 만듦
	- PowerShell의 객체는 파일 이름, 사용자 이름 또는 크기를 데이터(**속성**)로 포함할 수 있고, 파일 복사나 프로세스 중지와 같은 기능(**메서드**)을 수행할 수 있음
	- 전통적인 명령 셸의 기본 명령들은 텍스트 기반이며, 이는 데이터를 평문 텍스트로 처리하고 출력한다는 의미
	- 반면, PowerShell에서 `cmdlet (command-let으로 발음)`이 실행될 때, 이는 속성과 메서드를 유지하는 객체를 반환함
	- 이러한 객체들은 추가적인 텍스트 파싱이 필요하지 않기 때문에 더 강력하고 유연한 데이터 조작을 가능하게 함

4. PowerShell Basics
	- Remmina 클라언트를 사용하여 SSH로 대상 VM 연결

	1. Launching PowerShell
		1. GUI에서 실행하는 방법
			- 시작 메뉴: Windows 시작 메뉴 검색창에 `powershell` 입력 -> Windows PowerShell 또는 PowerShell 클릭
			- 실행 대화상자: `Win + R` -> `powershell` 입력 -> Enter
			- 파일 탐색기: 원하는 폴더로 이동 -> 주소 표시줄에 `powershell` 입력 -> Enger (해당 디렉토리에서 PowerShell 열림)
			- 작업 관리자: 작업 관리자 열기 -> 파일 > 새 작업 실행 -> `powershell` 입력 -> Enter
		
		2. Command Prompt에서 실행
			- `cmd.exe`에서 `powershell` 입력 후 Enter
			- Remmina 클라이언트를 이용한 VM이므로 명령 프롬프트에만 접근 가능하므로 이 방법 사용
			- PowerShell이 실행되면 현재 작업 디렉토리에서 `PS` 프롬프트가 표시됨
				![[Pasted image 20250714213930.png]]

	2. Basic Syntax: Verb - Noun
		- PowerShell 명령은 `cmdlets (command-lets로 발음)`
		- 기존 Windows 명령보다 훨씬 강력하며 고급 데이터 조작이 가능함
		- `cmdlets`는 일관된 동사 - 명사 명명 규칙을 따름
		- verb (동사): 동작 설명 & noun (명사): 동작이 수행되는 객체를 지정
		- ex:
			- `Get-Content`: 파일의 내용을 검색 (gets)하여 콘솔에 표시
			- `Set-Location`: 현재 작업 디렉토리를 변경 (sets)

	3. Basic Cmdlets
		1. `Get-Command`
			- 현재 PowerShell 세션에서 실행할 수 있는 모든 사용 가능한 `cmdlets`, functions, aliases, scripts를 나열함
			- 사용할 수 있는 명령을 검색하는 필수 도구
				![[Pasted image 20250714214111.png]]
			- 각 CommandInfo 객체에 대해 일부 필수 정보 (properties; 속성)가 콘솔에 표시됨 (표시된 속성 값을 기반으로 명령 목록을 필터링할 수 있음)
			- 명령 유형별 필터링
				- "Function" 유형의 사용 가능한 명령만 표시하려면 `-CommandType "Function"`을 사용함
					![[Pasted image 20250714214738.png]]
				- How would you retrieve a list of commands that **start with** the verb `Remove`? -> `Get-Command -Name Remove*`

		2. `Get-Help`
			- `cmdlets`에 대한 자세한 정보를 제공하는 필수 cmdlet
			- cmdlets, usage, parameters, examples를 포함함 (PowerShell 명령 사용법을 배우는 데 필수적인 cmdlet) 
			- `Get-Help` 추가 옵션
				- `Get-Help`는 기본 구문에 옵션을 추가하여 cmdlet에 대한 다른 유용한 정보를 얻을 수 있다고 보여줌
				- ex: `Get-Help -examples` -> 선택한 cmdlet의 일반적인 사용 방법 목록이 표시됨
				- What is the command to retrieve some example usage for the cmdlet `New-LocalUser`? -> `Get-Help New-LocalUser -examples`
			
			```powershell
PS C:\Users\captain> Get-Help Get-Date

NAME
    Get-Date

SYNOPSIS
    Gets the current date and time.

SYNTAX
    Get-Date [[-Date] <System.DateTime>] [-Day <System.Int32>] [-DisplayHint {Date | Time | DateTime}] [-Format <System.String>] [-Hour <System.Int32>] [-Millisecond <System.Int32>] [-Minute <System.Int32>] [-Month <System.Int32>] [-Second <System.Int32>] [-Year <System.Int32>] [<CommonParameters>]

    Get-Date [[-Date] <System.DateTime>] [-Day <System.Int32>] [-DisplayHint {Date | Time | DateTime}] [-Hour <System.Int32>] [-Millisecond <System.Int32>] [-Minute <System.Int32>] [-Month <System.Int32>] [-Second <System.Int32>] [-UFormat <System.String>] [-Year <System.Int32>] [<CommonParameters>]

DESCRIPTION
        The `Get-Date` cmdlet gets a DateTime object that represents the current date or a date that you specify. `Get-Date` can format the date and time in several .NET and UNIX formats. You can use `Get-Date` to generate a date or time character string, and then send the string to other cmdlets or programs.
        
        `Get-Date` uses the current culture settings of the operating system to determine how the output is formatted. To view your computer's settings, use `(Get-Culture).DateTimeFormat`.

RELATED LINKS
    Online Version: https://learn.microsoft.com/powershell/module/microsoft.powershell.utility/get-date?view=powershell-5.1&WT.mc_id=ps-gethelp
    ForEach-Object
    Get-Culture
    Get-Member
    New-Item
    New-TimeSpan
    Set-Date
    Set-Culture xref:International.Set-Culture

REMARKS
    To see the examples, type: "get-help Get-Date -examples".
    For more information, type: "get-help Get-Date -detailed".
    For technical information, type: "get-help Get-Date -full".
    For online help, type: "get-help Get-Date -online".
```
				
		3. `Get-Alias`
			- 사용자들의 전환을 쉽게 하기 위해 PowerShell에는 많은 기존 Windows 명령에 대한 `별칭 (alias); cmdlet의 단축키 또는 대체 이름`이 포함되어 있음
				![[Pasted image 20250714220354.png]]

	4. Where to Find and Download Cmdlets
		- PowerShell의 또다른 강력한 기능은 online repositories에서 추가 cmdlets를 다운로드하여 기능을 확장할 수 있다는 것임
		
		1. `Find-Module`
			- PowerShell Gallery와 같은 온라인 저장소에서 모듈 (cmdlets의 모음)을 검색하는 데 사용
			- 모듈의 정확한 이름을 모르는 경우, 유사한 이름의 모듈을 검색하는 것이 유용할 수 있음
			- ex: `Cmdlet -Property "pattern*"` -> 다음과 같은 표준 PowerShell 구문을 사용하여 Name 속성을 필터링하고 모듈의 부분 이름에 와일드카드 (`*`)를 추가하면 됨
				![[Pasted image 20250714225032.png]]

		2. `Install-Module`
			- 모듈을 식별한 후, `Install-Module`을 사용하여 저장소에서 모듈을 다운로드하고 설치할 수 있으며, 이를 통해 모듈에 포함된 새로운 cmdlets를 사용할 수 있음
				![[Pasted image 20250714225249.png]]

5. Navigating the File System and Working with Files
	- PowerShell은 파일 시스템 탐색과 파일 관리를 위한 다양한 cmdlet을 제공하며, 이들 중 많은 것들이 기존 Windows CLI (Command Line Interface)의 대응 명령어들과 유사함
	- PowerShell의 장점 중 하나는 하나의 cmdlet으로 파일과 디렉터리를 모두 처리할 수 있다는 점

	1. 파일 및 디렉터리 조회
		- `Get-Childitem`은 Command Prompt의 `dir` 명령어 (Unix 계열 시스템의 `ls`)와 유사하게 `-Path` 매개변수로 지정된 위치의 파일과 디렉터리를 나열함
		- Path가 지정되지 않으면 현재 작업 디렉터리의 내용을 표시함
			![[Pasted image 20250715144600.png]]

	2. 디렉터리 이동
		- `Set-Location` cmdlet을 사용하면 다른 디렉터리로 이동할 수 있음
		- 이는 현재 디렉터리를 변경하여 지정된 경로로 이동시켜주며, Command Prompt의 `cd` 명령어와 유사함
			![[Pasted image 20250715145240.png]]

	3. 파일 및 디렉터리 생성
		- 기존 Windows CLI과는 달리, PowerShell은 `New-Item` cmdlet 하나로 파일과 디렉터리 생성 및 관리 과정을 단순화 함
		- 아이템의 경로와 타입 (파일 or 디렉터리)을 지정해야 함
			```powershell
PS C:\Users\captain\Documents> New-Item -Path ".\captain-cabin\captain-wardrobe" -ItemType "Directory"

    Directory: C:\Users\captain\Documents\captain-cabin

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----          9/4/2024  12:20 PM                captain-wardrobe

PS C:\Users\captain\Documents> New-Item -Path ".\captain-cabin\captain-wardrobe\captain-boots.txt" -ItemType "File"     

    Directory: C:\Users\captain\Documents\captain-cabin\captain-wardrobe

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----          9/4/2024  11:46 AM              0 captain-boots.txt
```

	4. 파일 및 디렉터리 삭제
		- `Remove-Item` cmdlet은 디렉터리와 파일을 모두 삭제할 수 있음
		- Windows CLI에서는 `rmdir`과 `del`이라는 별도의 명령어를 사용함
			```powershell
PS C:\Users\captain\Documents> Remove-Item -Path ".\captain-cabin\captain-wardrobe\captain-boots.txt"
PS C:\Users\captain\Documents> Remove-Item -Path ".\captain-cabin\captain-wardrobe"
```

	5. 파일 및 디렉터리 복사 / 이동
		- 파일 및 디렉터리 복사: `Copy-Item`
		- 파일 및 디렉터리 이동: `Move-Item`
			```powershell
PS C:\Users\captain\Documents> Copy-Item -Path .\captain-cabin\captain-hat.txt -Destination .\captain-cabin\captain-hat2.txt
PS C:\Users\captain\Documents> Get-ChildItem -Path ".\captain-cabin\" 

    Directory: C:\Users\captain\Documents\captain-cabin

Mode                 LastWriteTime         Length Name 
----                 -------------         ------ ----
d-----          9/4/2024  12:50 PM                captain-wardrobe
-a----          9/4/2024  12:50 PM              0 captain-boots.txt
-a----          9/4/2024  12:14 PM            264 captain-hat.txt
-a----          9/4/2024  12:14 PM            264 captain-hat2.txt
-a----          9/4/2024  12:37 PM           2116 ship-flag.txt
```

	6. 파일 내용 읽기
		- `Get-Content`
		- Command Prompt의 `type` 명령어 (또는 Unix 계열 시스템의 `cat`)와 유사하게 작동함
			![[Pasted image 20250715152515.png]]

	7. 주요 Cmdlet 요약
		![[Pasted image 20250715152610.png]]

6. Piping, Filtering, and Sorting Data
	1. Piping
		- 파이핑은 명령줄 환경에서 사용되는 기술로, 한 명령의 출력을 다른 명령의 입력으로 사용할 수 있게 해주는 기능
		- 이는 데이터가 한 명령에서 다음 명령으로 흘러가는 일련의 작업 시퀀스를 만듦
		- `|` 기호로 표현되며, Windows CLI와 Unix 기반 셸에서 널리 사용됨
		- PowerShell에서 파이핑은 단순히 텍스트가 아닌 `objects (객체)`를 전달하기 때문에 더욱 강력함
		- 이 객체들은 데이터뿐만 아니라 데이터를 설명하고 상호작용하는 `properties (속성)` `methods (메서드)`도 함께 전달함
		- ex: 디렉터리의 파일 목록을 가져와서 크기별로 정렬하는 예제
			![[Pasted image 20250715181217.png]]

	2. 정렬하기: `Sort-Object`
		- 지정된 속성을 기준으로 객체를 정렬함
		- 파이핑과 결합하면 고급 데이터 조작과 분석이 가능함

	3. 필터링하기: `Where-Object`
		- 지정된 조건을 기반으로 객체를 필터링하여 기준에 맞는 객체만 반환함
		- ex: .txt 파일만 필터링
			```powershell
PS C:\Users\captain\Documents\captain-cabin> Get-ChildItem | Where-Object -Property "Extension" -eq ".txt"

    Directory: C:\Users\captain\Documents\captain-cabin

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----          9/4/2024  12:50 PM              0 captain-boots.txt
-a----          9/4/2024  12:14 PM            264 captain-hat.txt
-a----          9/4/2024  12:14 PM            264 captain-hat2.txt
-a----          9/4/2024  12:37 PM           2116 ship-flag.txt
```

	4. Comparison Operators (비교 연산자들)
		- `-eq`: 같음 (equal to)
		- `-ne`: 같지 않음 (not equal) -> 지정된 기준을 기반으로 객체를 결과에서 제외
		- `-gt`: 보다 큼 (greater than) -> 지정된 값을 초과하는 객체만 필터링 (엄격한 비교)
		- `-ge`: 보다 크거나 같음 (greater than or equal to) -> -gt와 -eq의 조합
		- `-lt`: 보다 작음 (less than) -> 지정됨 값보다 엄격히 작은 객체만 포함
		- `-le`: 보다 작거나 같음 (less than or equal to) -> -lt와 -eq의 조합
			- ex: How would you retrieve the items in the current directory with size greater than 100? -> `Get-ChildItem | Where-Object -Property "Length" -gt "100"`

		- `-like`: 지정된 패턴과 일치하는 속성을 가진 객체를 필터링
			- ex:
				```powershell
PS C:\Users\captain\Documents\captain-cabin> Get-ChildItem | Where-Object -Property "Name" -like "ship*"

    Directory: C:\Users\captain\Documents\captain-cabin

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----          9/4/2024  12:37 PM           2116 ship-flag.txt
```

	5. 객체 선택하기: `Select-Object`
		- 객체에서 특정 속성을 선택하거나 반환되는 객체 수를 제한하는 데 사용됨
		- 필요한 세부사항만 표시하도록 출력을 개선하는 데 유용함
		- ex: 특정 속성만 선택
			```powershell
PS C:\Users\captain\Documents\captain-cabin> Get-ChildItem | Select-Object Name,Length

Name              Length
----              ------
captain-wardrobe
captain-boots.txt 0
captain-hat.txt   264
captain-hat2.txt  264
ship-flag.txt     2116
```

	6. 복합 파이프라인
		- cmdlet 파이프라인은 두 개의 cmdlet 사이에서만 파이핑하는 것에 제한되지 않고 더 많은 명령을 추가하여 확장할 수 있음
		- ex: `C:\Users\captain\Documents\captain-cabin` 디렉터리에서 가장 큰 파일을 표시하는 목표로 정렬과 필터링을 결합한 cmdlet 파이프라인 구성하기
			![[Pasted image 20250715185034.png]]

	7. 텍스트 검색하기: `Select-String`
		- 파일 내에서 텍스트 패턴을 검색하며, Unix 기반 시스템의 `grep`이나 Windows 명령 프롬프트의 `findstr`과 유사함
		- 로그 파일이나 문서에서 특정 내용을 찾는 데 일반적으로 사용됨
			```powershell
PS C:\Users\captain\Documents\captain-cabin> Select-String -Path ".\captain-hat.txt" -Pattern "hat"

captain-hat.txt:8:Don't touch my hat!
```
		
		- 정규 표현식 (Regular Expressions) 지원
			- `Select-String` cmdlet은 정규 표현식 (`regex`)을 완전히 지원함
			- 이 고급 기능은 파일 내에서 복잡한 패턴 매칭을 가능하게 하여 텍스트 데이터를 검색하고 분석하는 강력한 도구

7. System and Network Information
	1. `Get-ComputerInfo`
		- Operating System Information (운영 체제 정보), Hardware Specifications (하드웨어 사양), BIOS details (BIOS 세부 정보) 등을 포함한 포괄적인 시스템 정보를 검색함
		- 단일 명령으로 전체 시스템 구성의 스냅샷을 제공함
		- 기존의 `systeminfo` 명령은 같은 세부 정보 중 일부만을 검색함
			```powershell
PS C:\Users\captain> Get-ComputerInfo

WindowsBuildLabEx                                       : 20348.859.amd64fre.fe_release_svc_prod2.220707-1832
WindowsCurrentVersion                                   : 6.3
WindowsEditionId                                        : ServerDatacenter
WindowsInstallationType                                 : Server Core
WindowsInstallDateFromRegistry                          : 4/23/2024 6:36:29 PM
WindowsProductId                                        : 00454-60000-00001-AA763
WindowsProductName                                      : Windows Server 2022 Datacenter
[...]
```

	2. `Get-LocalUser`
		- 사용자 계정을 관리하고 시스템의 보안 구성을 이해하는데 필수적인 cmdlet
		- 시스템의 모든 로컬 사용자 계정을 나열함
		- 기본 출력은 각 사용자에 대해 사용자 이름, 계정 상태, 설명을 표시함
			```powershell
PS C:\Users\captain> Get-LocalUser

Name               Enabled Description 
----               ------- -----------
Administrator      True    Built-in account for administering the computer/domain
captain            True    The beloved captain of this pirate ship.
DefaultAccount     False   A user account managed by the system.
Guest              False   Built-in account for guest access to the computer/domain
WDAGUtilityAccount False   A user account managed and used by the system for Windows Defender Application Guard scenarios.
```

	3. System's network configuration cmdlets
		- 기존의 `ipconfig` 명령과 유사하게, 다음 두 cmdlet을 사용하여 시스템의 네트워크 구성에 대한 자세한 정보를 검색할 수 있음

		1. `Get-NetIPConfiguration`
			- IP주소, DNS 서버, 게이트웨이 구성을 포함한 시스템의 네트워크 인터페이스에 대한 자세한 정보를 제공함
				![[Pasted image 20250716105642.png]]

		2. `Get-NetIPAddress`
			- 네트워크 인터페이스에 할당된 IP 주소에 대한 특정 세부 정보가 필요한 경우, 이 cmdlet을 이용하여 현재 활성 상태가 아닌 주소를 포함하여 시스템에 구성된 모든 IP 주소의 세부 정보를 표시함
				```powershell
PS C:\Users\captain> Get-NetIPAddress

IPAddress         : fe80::3fef:360c:304:64e%5
InterfaceIndex    : 5
InterfaceAlias    : Ethernet
AddressFamily     : IPv6
Type              : Unicast
PrefixLength      : 64
PrefixOrigin      : WellKnown
SuffixOrigin      : Link
AddressState      : Preferred
ValidLifetime     : Infinite ([TimeSpan]::MaxValue)
PreferredLifetime : Infinite ([TimeSpan]::MaxValue)
SkipAsSource      : False
PolicyStore       : ActiveStore

IPAddress         : ::1
InterfaceIndex    : 1
InterfaceAlias    : Loopback Pseudo-Interface 1
AddressFamily     : IPv6
[...]

IPAddress         : 10.10.178.209
InterfaceIndex    : 5
InterfaceAlias    : Ethernet
AddressFamily     : IPv4
[...]

IPAddress         : 127.0.0.1
InterfaceIndex    : 1
InterfaceAlias    : Loopback Pseudo-Interface 1
AddressFamily     : IPv4
[...]
```

8. Real-Time System Analysis
	- 실행 중인 프로세스, 서비스, 활성 네트워크 연결과 같은 동적 측면에 관한 고급 시스템 정보를 수집하기 위해, 정적 머신 세부사항을 넘어서는 다양한 cmdlet을 활용할 수 있음

	1. `Get-Process`
		- 현재 실행 중인 모든 프로세스에 대한 상세한 보기를 제공하며, CPU 및 메모리 사용량을 포함하여 모니터링 및 문제 해결에 강력한 도구
			![[Pasted image 20250716124220.png]]

	2. `Get-Service`
		- 머신의 서비스 상태에 대한 정보를 검색할 수 있으며, 실행 중인 서비스, 중지된 서비스, 또는 일시정지된 서비스 등을 확인할 수 있음
		- 시스템 관리자가 문제 해결시 광범위하게 사용하지만, 포렌식 분석가들이 시스템에 설치된 비정상적인 서비스를 찾을 때도 활용됨
			![[Pasted image 20250716124357.png]]
		
	3. `Get-NetTCPConnection`
		- 활성 네트워크 연결을 모니터링하기 위해 해당 cmdlet은 현재 TCP 연결을 표시하여 로컬 및 원격 엔드포인트에 대한 통찰력을 제공함
		- 또한, 숨겨진 백도어나 공격자가 제어하는 서버로의 확립된 연결을 발견할 수 있어 즉각 대응이나 악성코드 분석 작업 중에 특히 유용함
			![[Pasted image 20250716124959.png]]
		- What property retrieved by default by `Get-NetTCPConnection` contains information about the process that has started the connection? -> OwningProcess

	4. `Get-FileHash`
		- 파일 해시 생성에 유용한 cmdlet
		- 파일 무결성을 확인하고 잠재적인 변조를 탐지하는 데 도움이 되므로, 즉각 대응, 위협 헌팅, 악성코드 분석에 특히 유용함
			![[Pasted image 20250716125149.png]]

> [!INFO]
> ### `OwningProcess`
> - 이 속성은 해당 TCP 연결을 소유하고 있는 (즉, 연결을 시작한) 프로세스의 ID (PID)를 포함하고 있음
> - 이를 통해 어떤 프로세스가 특정 네트워크 연결을 만들었는지 알 수 있음
> ```powershell
> Get-NetTCPConnection | Select-Object LocalAddress, LocalPort, RemoteAddress, RemotePort, State, OwningProcess
> ```
> - 위의 예와 같이 하면 각 TCP 연결과 함깨 해당 연결을 소유한 프로세스 ID를 볼 수 있음

9. Scripting
	1. Scripting이란?
		- 텍스트 파일 (script)에 포함된 일련의 명령들을 작성하고 실행하는 과정으로, PowerShell과 같은 셸에서 일반적으로 수동으로 수행하는 작업들을 자동화하는 것
		- 스크립팅은 컴퓨터에서 할 일 목록을 주는 것과 같으며, 스크립트의 각 줄은 컴퓨터가 자동으로 수행할 작업임

	2. 사이버 보안 분야에서의 활용
		1. Blue Team 전문가
			- Incident responders, Malware analysts, Threat hunters와 같은 블루팀 전문가들에게 PowerShell 스크립트는 다음과 같은 다양한 작업을 자동화할 수 있음
				- Log analysis; 로그 분석
				- Detecting anomalies; 이상 징후 탐지
				- Extracting indicators of compromise (IOCs); 침해 지표 추출
				- Reverse-engineer malicious code (Malware) or automate the scanning of systems for signs of intrusion; 시스템의 침입 흔적 스캔 자동화

		2. Red Team 전문가
			- Penetration testers, Ethical hackers와 같은 레드팀에게 PowerShell 스크립트는 다음과 같은 작업을 자동화할 수 있음
				- Enumeration; 시스템 열거
				- Executing remote commands; 원격 명령 실행
				- Crafting obfuscated scripts to bypass defences; 방어 시스템을 우회하기 위한 난독화된 스크립트 작성

		3. System administrators
			- 사이버 보안 맥락에서 시스템 관리자들은 PowerShell 스크립팅을 통해 다음과 같은 이점을 얻을 수 있음
				- Automating integrity checks; 무결성 검사 자동화
				- Managing system configurations; 시스템 구성 관리
				- Securing networks (especially in remote or large-scale environments); 네트워크 보안 관리 (특히 원격 또는 대규모 환경에서)
				- Enforce security policies; 보안 정책 시행
				- Monitor systems health; 시스템 상태 모니터링
				- Respond automatically to security incidents (thus enhancing the overall security posture); 보안 인시던트에 대한 자동 대응

	3. `Invoke-Command` cmdlet
		- `Invoke-Command`는 원격 시스템에서 명령을 실행하는 데 필수적이며, 시스템 관리자, 보안 엔지니어, 침투 테스터에게 기본적인 도구
		- 효율적인 원격 관리를 가능하게 하고, 스크립팅과 결합하여 여러 시스템에 걸친 작업의 자동화를 가능하게 함
		- 침투 테스터나 공격자가 참여하는 동안 대상 시스템에서 payloads (전송되는 '순수한 데이터'. 전송의 근본적인 목적이 되는 데이터의 일부분으로, 그 데이터와 함께 전송되는 헤더, 메타데이터와 같은 부분은 제외함. 컴퓨터 보안에서 페이로드는 멀웨어의 일부를 의미함)나 명령을 실행하는 데도 사용할 수 있음
			```powershell
PS C:\Users\captain> Get-Help Invoke-Command -examples

NAME
    Invoke-Command
    
SYNOPSIS
    Runs commands on local and remote computers.
    
    ------------- Example 1: Run a script on a server -------------
    
    Invoke-Command -FilePath c:\scripts\test.ps1 -ComputerName Server01
    
    The FilePath parameter specifies a script that is located on the local computer. 
    The script runs on the remote computer and the results are returned to the local computer.

    --------- Example 2: Run a command on a remote server ---------

    Invoke-Command -ComputerName Server01 -Credential Domain01\User01 -ScriptBlock { Get-Culture }

    The ComputerName parameter specifies the name of the remote computer. 
    The Credential parameter is used to run the command in the security context of Domain01\User01, 
    a user who has permission to run commands. 
    The ScriptBlock parameter specifies the command to be run on the remote computer.

    In response, PowerShell requests the password and an authentication method for the User01 account. 
    It then runs the command on the Server01 computer and returns the result.
```
		- 위의 `Get-Help "exmaples"` 
			1. 첫 번째 예시
				- 이 cmdlet이 원격 컴퓨터에서 작업을 자동화하기 위해 사용자 정의 스크립트와 매우 쉽게 결합될 수 있음을 보여줌
			2. 두 번째 예시
				- `Invoke-Command`의 강력함을 활용하기 위해 스크립팅 방법을 알 필요가 없다는 것을 보여줌
				- 실제로 cmdlet 구문에 `-ScriptBLock { ... }` 매개변수를 추가하면 원격 컴퓨터에서 어떤 명령 (또는 명령 시퀀스)이든 실행할 수 있음
				- 결과는 원격 컴퓨터 자체의 로컬 PowerShell 세션에서 명령을 입력하는 것과 동일함

		- What is the syntax to execute the command `Get-Service` on a remote computer named "RoyalFortune"? Assume you don't need to provide credentials to establish the connection. [for the sake of this question, avoid the use of quotes (" or ') in your answer] -> Invoke-Command -ComputerName RoyalFortune -ScriptBlock { Get-Service }

> [!INFO]
> # `Invoke-Command`
> ## 명령어 이름
> 
> Invoke-Command
> 
> ## 개요
> 
> 로컬 및 원격 컴퓨터에서 명령을 실행합니다.
> 
> ## 예제들
> 
> ### 예제 1: 서버에서 스크립트 실행
> 
> ```powershell
> Invoke-Command -FilePath c:\scripts\test.ps1 -ComputerName Server01
> ```
> 
> **설명:**
> 
> - FilePath 매개변수는 로컬 컴퓨터에 위치한 스크립트를 지정합니다
> - 스크립트는 원격 컴퓨터에서 실행되고 결과는 로컬 컴퓨터로 반환됩니다
> 
> ### 예제 2: 원격 서버에서 명령 실행
> 
> ```powershell
> Invoke-Command -ComputerName Server01 -Credential Domain01\User01 -ScriptBlock {
>     Get-Culture
> }
> ```
> 
> **설명:**
> 
> - ComputerName 매개변수는 원격 컴퓨터의 이름을 지정합니다
> - Credential 매개변수는 명령을 실행할 권한이 있는 사용자인 Domain01\User01의 보안 컨텍스트에서 명령을 실행하는 데 사용됩니다
> - ScriptBlock 매개변수는 원격 컴퓨터에서 실행할 명령을 지정합니다
> 
> **응답:** PowerShell은 User01 계정의 비밀번호와 인증 방법을 요청합니다. 그 다음 Server01 컴퓨터에서 명령을 실행하고 결과를 반환합니다.
> 
> ### 예제 3: 지속적인 연결에서 명령 실행
> 
> ```powershell
> $s = New-PSSession -ComputerName Server02 -Credential Domain01\User01
> Invoke-Command -Session $s -ScriptBlock { Get-Culture }
> ```
> 
> **설명:**
> 
> - `New-PSSession` cmdlet은 Server02 원격 컴퓨터에 세션을 생성하고 `$s` 변수에 저장합니다
> - 일반적으로 원격 컴퓨터에서 일련의 명령을 실행할 때만 세션을 생성합니다
> - `Invoke-Command` cmdlet은 Server02에서 `Get-Culture` 명령을 실행합니다
> - Session 매개변수는 `$s` 변수에 저장된 세션을 지정합니다
> 
> **응답:** PowerShell은 Server02 컴퓨터의 세션에서 명령을 실행합니다.
> 
> ### 예제 4: 데이터를 공유하는 일련의 명령을 실행하기 위해 세션 사용
> 
> ```powershell
> Invoke-Command -ComputerName Server02 -ScriptBlock { $p = Get-Process PowerShell }
> Invoke-Command -ComputerName Server02 -ScriptBlock { $p.VirtualMemorySize }
> 
> $s = New-PSSession -ComputerName Server02
> Invoke-Command -Session $s -ScriptBlock { $p = Get-Process PowerShell }
> Invoke-Command -Session $s -ScriptBlock { $p.VirtualMemorySize }
> ```
> 
> **출력:**
> 
> ```
> 17930240
> ```
> 
> **설명:**
> 
> - 처음 두 명령은 `Invoke-Command`의 ComputerName 매개변수를 사용하여 Server02 원격 컴퓨터에서 명령을 실행합니다
> - 첫 번째 명령은 `Get-Process` cmdlet을 사용하여 원격 컴퓨터의 PowerShell 프로세스를 가져와서 `$p` 변수에 저장합니다
> - 두 번째 명령은 PowerShell 프로세스의 VirtualMemorySize 속성 값을 가져옵니다
> - ComputerName 매개변수를 사용하면 PowerShell은 명령을 실행하기 위해 새 세션을 생성합니다. 명령이 완료되면 세션이 닫힙니다
> - `$p` 변수는 하나의 연결에서 생성되었지만 두 번째 명령을 위해 생성된 연결에서는 존재하지 않습니다
> - 이 문제는 원격 컴퓨터에 지속적인 세션을 생성한 다음 동일한 세션에서 두 명령을 모두 실행하여 해결됩니다
> - `New-PSSession` cmdlet은 Server02 컴퓨터에 지속적인 세션을 생성하고 `$s` 변수에 세션을 저장합니다
> - 이어지는 `Invoke-Command` 줄은 Session 매개변수를 사용하여 동일한 세션에서 두 명령을 모두 실행합니다
> - 두 명령이 모두 동일한 세션에서 실행되므로 `$p` 값이 활성 상태로 유지됩니다
> 
> ### 예제 5: 변수에 저장된 스크립트 블록으로 명령 호출
> 
> ```powershell
> $command = {
>     Get-EventLog -LogName 'Windows PowerShell' |
>         Where-Object { $_.Message -like '*certificate*' }
> }
> Invoke-Command -ComputerName S1, S2 -ScriptBlock $command
> ```
> 
> **설명:**
> 
> - `$command` 변수는 스크립트 블록으로 형식화된 `Get-EventLog` 명령을 저장합니다
> - `Invoke-Command`는 S1과 S2 원격 컴퓨터에서 `$command`에 저장된 명령을 실행합니다
> 
> ### 예제 6: 여러 컴퓨터에서 단일 명령 실행
> 
> ```powershell
> $parameters = @{
>     ComputerName      = 'Server01', 'Server02', 'TST-0143', 'localhost'
>     ConfigurationName = 'MySession.PowerShell'
>     ScriptBlock       = { Get-EventLog 'Windows PowerShell' }
> }
> Invoke-Command @parameters
> ```
> 
> **설명:**
> 
> - ComputerName 매개변수는 쉼표로 구분된 컴퓨터 이름 목록을 지정합니다
> - 컴퓨터 목록에는 로컬 컴퓨터를 나타내는 localhost 값이 포함됩니다
> - ConfigurationName 매개변수는 대체 세션 구성을 지정합니다
> - ScriptBlock 매개변수는 각 컴퓨터에서 Windows PowerShell 이벤트 로그를 가져오기 위해 `Get-EventLog`를 실행합니다
> 
> ### 예제 7: 여러 컴퓨터에서 호스트 프로그램 버전 가져오기
> 
> ```powershell
> $version = Invoke-Command -ComputerName (Get-Content Machines.txt) -ScriptBlock {
>     (Get-Host).Version
> }
> ```
> 
> **설명:**
> 
> - 하나의 명령만 실행되므로 각 컴퓨터에 지속적인 연결을 생성할 필요가 없습니다
> - 대신 이 명령은 ComputerName 매개변수를 사용하여 컴퓨터를 지정합니다
> - 컴퓨터를 지정하기 위해 `Get-Content` cmdlet을 사용하여 컴퓨터 이름 파일인 Machine.txt 파일의 내용을 가져옵니다
> - `Invoke-Command` cmdlet은 원격 컴퓨터에서 `Get-Host` 명령을 실행합니다
> - 점 표기법을 사용하여 PowerShell 호스트의 Version 속성을 가져옵니다
> - 이러한 명령은 한 번에 하나씩 실행됩니다. 명령이 완료되면 모든 컴퓨터의 명령 출력이 `$version` 변수에 저장됩니다
> - 출력에는 데이터가 발생한 컴퓨터의 이름이 포함됩니다
> 
> ### 예제 8: 여러 원격 컴퓨터에서 백그라운드 작업 실행
> 
> ```powershell
> $s = New-PSSession -ComputerName Server01, Server02
> Invoke-Command -Session $s -ScriptBlock { Get-EventLog system } -AsJob
> 
> Id   Name    State      HasMoreData   Location           Command
> ---  ----    -----      -----         -----------        ---------------
> 1    Job1    Running    True          Server01,Server02  Get-EventLog system
> 
> $j = Get-Job
> $j | Format-List -Property *
> 
> HasMoreData   : True
> StatusMessage :
> Location      : Server01,Server02
> Command       : Get-EventLog system
> JobStateInfo  : Running
> Finished      : System.Threading.ManualResetEvent
> InstanceId    : e124bb59-8cb2-498b-a0d2-2e07d4e030ca
> Id            : 1
> Name          : Job1
> ChildJobs     : {Job2, Job3}
> Output        : {}
> Error         : {}
> Progress      : {}
> Verbose       : {}
> Debug         : {}
> Warning       : {}
> StateChanged  :
> 
> $results = $j | Receive-Job
> ```
> 
> **설명:**
> 
> - `New-PSSession` cmdlet은 Server01 및 Server02 원격 컴퓨터에 세션을 생성합니다
> - `Invoke-Command` cmdlet은 각 세션에서 백그라운드 작업을 실행합니다
> - 이 명령은 AsJob 매개변수를 사용하여 백그라운드 작업으로 명령을 실행합니다
> - 이 명령은 두 원격 컴퓨터에서 실행되는 각 작업에 대해 하나씩 두 개의 자식 작업 객체를 포함하는 작업 객체를 반환합니다
> - `Get-Job` 명령은 작업 객체를 `$j` 변수에 저장합니다
> - `$j` 변수는 `Format-List` cmdlet으로 파이프되어 작업 객체의 모든 속성을 목록으로 표시합니다
> - 마지막 명령은 작업 결과를 가져옵니다. `$j`의 작업 객체를 `Receive-Job` cmdlet으로 파이프하고 결과를 `$results` 변수에 저장합니다
> 
> ### 예제 9: 원격 컴퓨터에서 실행되는 명령에 로컬 변수 포함
> 
> ```powershell
> $Log = 'Windows PowerShell'
> Invoke-Command -ComputerName Server01 -ScriptBlock {
>     Get-EventLog -LogName $Using:Log -Newest 10
> }
> ```
> 
> **설명:**
> 
> - `$Log` 변수는 이벤트 로그 이름인 Windows PowerShell을 저장합니다
> - `Invoke-Command` cmdlet은 Server01에서 `Get-EventLog`를 실행하여 이벤트 로그에서 최신 10개 이벤트를 가져옵니다
> - LogName 매개변수의 값은 로컬 세션에서 생성되었음을 나타내기 위해 `Using` 범위 수정자가 앞에 붙은 `$Log` 변수입니다(원격 세션이 아님)
> 
> ### 예제 10: 컴퓨터 이름 숨기기
> 
> ```powershell
> Invoke-Command -ComputerName S1, S2 -ScriptBlock { Get-Process PowerShell }
> 
> PSComputerName    Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id   ProcessName
> --------------    -------  ------    -----      ----- -----   ------     --   -----------
> S1                575      15        45100      40988   200     4.68     1392 PowerShell
> S2                777      14        35100      30988   150     3.68     67   PowerShell
> 
> Invoke-Command -ComputerName S1, S2 -HideComputerName -ScriptBlock {
>     Get-Process PowerShell
> }
> 
> Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id   ProcessName
> -------  ------    -----      ----- -----   ------     --   -----------
> 575      15        45100      40988   200     4.68     1392 PowerShell
> 777      14        35100      30988   150     3.68     67   PowerShell
> ```
> 
> **설명:**
> 
> - 처음 두 명령은 `Invoke-Command`를 사용하여 PowerShell 프로세스에 대한 `Get-Process` 명령을 실행합니다
> - 첫 번째 명령의 출력에는 명령이 실행된 컴퓨터의 이름이 포함된 PsComputerName 속성이 포함됩니다
> - HideComputerName을 사용하는 두 번째 명령의 출력에는 PsComputerName 열이 포함되지 않습니다
> 
> ### 예제 11: 스크립트 블록에서 Param 키워드 사용
> 
> ```powershell
> $parameters = @{
>     ComputerName = 'Server01'
>     ScriptBlock  = {
>         Param ($param1, $param2)
>         Get-ChildItem -Name $param1 -Include $param2
>     }
>     ArgumentList = 'a*', '*.pdf'
> }
> Invoke-Command @parameters
> 
> aa.pdf
> ab.pdf
> ac.pdf
> az.pdf
> ```
> 
> **설명:**
> 
> - `Invoke-Command`는 두 개의 변수 `$param1`과 `$param2`를 정의하는 ScriptBlock 매개변수를 사용합니다
> - `Get-ChildItem`은 변수 이름과 함께 명명된 매개변수 Name 및 Include를 사용합니다
> - ArgumentList는 변수에 값을 전달합니다
> 
> ### 예제 12: 스크립트 블록에서 $args 자동 변수 사용
> 
> ```powershell
> $parameters = @{
>     ComputerName = 'Server01'
>     ScriptBlock  = { Get-ChildItem $args[0] $args[1] }
>     ArgumentList = 'C:\Test', '*.txt*'
> }
> Invoke-Command @parameters
> 
> Directory: C:\Test
> 
> Mode                 LastWriteTime         Length Name
> ----                 -------------         ------ ----
> -a---           6/12/2019    15:15            128 alog.txt
> -a---           7/27/2019    15:16            256 blog.txt
> -a---           9/28/2019    17:10             64 zlog.txt
> ```
> 
> **설명:**
> 
> - `Invoke-Command`는 ScriptBlock 매개변수를 사용하고 `Get-ChildItem`은 `$args[0]` 및 `$args[1]` 배열 값을 지정합니다
> - ArgumentList는 Path 및 Filter에 대한 `Get-ChildItem` 매개변수 위치에 `$args` 배열 값을 전달합니다
> 
> ### 예제 13: 텍스트 파일에 나열된 모든 컴퓨터에서 스크립트 실행
> 
> ```powershell
> $parameters = @{
>     ComputerName = (Get-Content Servers.txt)
>     FilePath     = 'C:\Scripts\Sample.ps1'
>     ArgumentList = 'Process', 'Service'
> }
> Invoke-Command @parameters
> ```
> 
> **설명:**
> 
> - 명령을 제출하면 `Sample.ps1` 파일의 내용이 스크립트 블록으로 복사되고 각 원격 컴퓨터에서 스크립트 블록이 실행됩니다
> - 이 절차는 ScriptBlock 매개변수를 사용하여 스크립트 내용을 제출하는 것과 같습니다
> 
> ### 예제 14: URI를 사용하여 원격 컴퓨터에서 명령 실행
> 
> ```powershell
> $LiveCred = Get-Credential
> $parameters = @{
>     ConfigurationName = 'Microsoft.Exchange'
>     ConnectionUri     = 'https://ps.exchangelabs.com/PowerShell'
>     Credential        = $LiveCred
>     Authentication    = 'Basic'
>     ScriptBlock       = { Set-Mailbox Dan -DisplayName 'Dan Park' }
> }
> Invoke-Command @parameters
> ```
> 
> **설명:**
> 
> - 첫 번째 줄은 `Get-Credential` cmdlet을 사용하여 Windows Live ID 자격 증명을 `$LiveCred` 변수에 저장합니다. PowerShell은 사용자에게 Windows Live ID 자격 증명을 입력하라는 메시지를 표시합니다
> - `$parameters` 변수는 `Invoke-Command` cmdlet에 전달될 매개변수를 포함하는 해시 테이블입니다
> - `Invoke-Command` cmdlet은 Microsoft.Exchange 세션 구성을 사용하여 `Set-Mailbox` 명령을 실행합니다
> - ConnectionURI 매개변수는 Exchange 서버 끝점의 URL을 지정합니다
> - Credential 매개변수는 `$LiveCred` 변수에 저장된 자격 증명을 지정합니다
> - AuthenticationMechanism 매개변수는 기본 인증 사용을 지정합니다
> - ScriptBlock 매개변수는 명령이 포함된 스크립트 블록을 지정합니다
> 
> ### 예제 15: 세션 옵션 사용
> 
> ```powershell
> $so = New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck
> $parameters = @{
>     ComputerName  = 'server01'
>     UseSSL        = $true
>     ScriptBlock   = { Get-HotFix }
>     SessionOption = $so
>     Credential    = 'server01\user01'
> }
> Invoke-Command @parameters
> ```
> 
> **설명:**
> 
> - `New-PSSessionOption` cmdlet은 들어오는 HTTPS 연결을 평가하는 동안 원격 끝에서 인증 기관, 정식 이름 및 해지 목록을 확인하지 않도록 하는 세션 옵션 객체를 생성합니다
> - SessionOption 객체는 `$so` 변수에 저장됩니다
> - **참고:** 이러한 검사를 비활성화하면 문제 해결에 편리하지만 명백히 안전하지 않습니다
> - `Invoke-Command` cmdlet은 `Get-HotFix` 명령을 원격으로 실행합니다
> - SessionOption 매개변수에는 `$so` 변수가 제공됩니다
> 
> ### 예제 16: 원격 명령에서 URI 리디렉션 관리
> 
> ```powershell
> $max = New-PSSessionOption -MaximumRedirection 1
> $parameters = @{
>     ConnectionUri    = 'https://ps.exchangelabs.com/PowerShell'
>     ScriptBlock      = { Get-Mailbox dan }
>     AllowRedirection = $true
>     SessionOption    = $max
> }
> Invoke-Command @parameters
> ```
> 
> **설명:**
> 
> - `New-PSSessionOption` cmdlet은 `$max` 변수에 저장되는 PSSessionOption 객체를 생성합니다
> - 이 명령은 MaximumRedirection 매개변수를 사용하여 PSSessionOption 객체의 MaximumConnectionRedirectionCount 속성을 1로 설정합니다
> - `Invoke-Command` cmdlet은 원격 Microsoft Exchange Server에서 `Get-Mailbox` 명령을 실행합니다
> - AllowRedirection 매개변수는 연결을 대체 끝점으로 리디렉션할 명시적 권한을 제공합니다
> - SessionOption 매개변수는 `$max` 변수에 저장된 세션 객체를 사용합니다
> - 결과적으로 ConnectionURI로 지정된 원격 컴퓨터가 리디렉션 메시지를 반환하면 PowerShell은 연결을 리디렉션하지만 새 대상이 다른 리디렉션 메시지를 반환하면 리디렉션 개수 값 1이 초과되어 `Invoke-Command`는 종료되지 않는 오류를 반환합니다
> 
> ### 예제 17: 원격 세션에서 네트워크 공유 액세스
> 
> ```powershell
> Enable-WSManCredSSP -Role Client -DelegateComputer Server02
> $s = New-PSSession Server02
> Invoke-Command -Session $s -ScriptBlock { Enable-WSManCredSSP -Role Server -Force }
> $parameters = @{
>     Session        = $s
>     ScriptBlock    = { Get-Item \\Net03\Scripts\LogFiles.ps1 }
>     Authentication = 'CredSSP'
>     Credential     = 'Domain01\Admin01'
> }
> Invoke-Command @parameters
> ```
> 
> **설명:**
> 
> - `Enable-WSManCredSSP` cmdlet은 Server01 로컬 컴퓨터에서 Server02 원격 컴퓨터로 CredSSP 위임을 활성화합니다
> - Role 매개변수는 Client를 지정하여 로컬 컴퓨터에서 CredSSP 클라이언트 설정을 구성합니다
> - `New-PSSession`은 Server02에 대한 PSSession 객체를 생성하고 이 객체를 `$s` 변수에 저장합니다
> - `Invoke-Command` cmdlet은 `$s` 변수를 사용하여 원격 컴퓨터 Server02에 연결합니다
> - ScriptBlock 매개변수는 원격 컴퓨터에서 `Enable-WSManCredSSP`를 실행합니다
> - Role 매개변수는 Server를 지정하여 원격 컴퓨터에서 CredSSP 서버 설정을 구성합니다
> - `$parameters` 변수는 네트워크 공유에 연결하기 위한 매개변수 값을 포함합니다
> - `Invoke-Command` cmdlet은 `$s`의 세션에서 `Get-Item` 명령을 실행합니다
> - 이 명령은 `\\Net03\Scripts` 네트워크 공유에서 스크립트를 가져옵니다
> - 이 명령은 CredSSP 값을 가진 Authentication 매개변수와 Domain01\Admin01 값을 가진 Credential 매개변수를 사용합니다
> 
> ### 예제 18: 많은 원격 컴퓨터에서 스크립트 시작
> 
> ```powershell
> $parameters = @{
>     ComputerName          = (Get-Content -Path C:\Test\Servers.txt)
>     InDisconnectedSession = $true
>     FilePath              = '\\Scripts\Public\ConfigInventory.ps1'
>     SessionOption         = @{
>         OutputBufferingMode = 'Drop'
>         IdleTimeout         = [timespan]::FromHours(12)
>     }
> }
> Invoke-Command @parameters
> ```
> 
> **설명:**
> 
> - 이 명령은 `Invoke-Command`를 사용하여 스크립트를 실행합니다
> - ComputerName 매개변수의 값은 텍스트 파일에서 원격 컴퓨터 이름을 가져오는 `Get-Content` 명령입니다
> - InDisconnectedSession 매개변수는 명령을 시작하는 즉시 세션을 연결 해제합니다
> - FilePath 매개변수의 값은 `Invoke-Command`가 각 컴퓨터에서 실행하는 스크립트입니다
> - SessionOption의 값은 해시 테이블입니다
> - OutputBufferingMode 값은 `Drop`으로 설정되고 IdleTimeout 값은 12시간으로 설정됩니다
> - 연결 해제된 세션에서 실행되는 명령과 스크립트의 결과를 가져오려면 `Receive-PSSession` cmdlet을 사용하세요

---

## 3. Linux Shells

- Who is the facilitator between the user and the OS? -> Shell
- What is the default shell in most Linux distributions? -> Bash

1. Shell에서 사용하는 Commands
	1. `pwd`
		- Print Working Directory
		- 현재 작업 디렉터리 확인

	2. `cd`
		- Change Directory
		- 디렉터리 변경

	3. `ls`
		- List
		- 디렉터리의 내용 확인

	4. `cat 파일이름.확장자`
		- Concatenate
		- 해당 파일의 내용 확인

	5. `grep`
		- Global Regular Expression Print
		- 파일 내에서 특정 단어나 패턴 검색
			```bash
user@ubuntu:~$ grep THM dictionary.txt
The flag is THM
```

2. Types of Linux Shells
	1. Current Shell 확인
		![[Pasted image 20250716170406.png]]

	2. Available Shells 확인
		- Linux OS에서 사용 가능한 쉘 목록도 확인 가능
		- `/etc/shells` 파일에는 리눅스 시스템에 설치된 모든 쉘이 포함되어 있음
			![[Pasted image 20250716170609.png]]

	3. Switch Shell
		- 쉘 간 전환은 OS에 있는 쉘 이름을 입력하면 해당 쉘이 열리는 것을 확인할 수 있음
			![[Pasted image 20250716171204.png]]
		- `chsh -s /usr/bin/zsh`: 기본 쉘을 영구적으로 변경

	4. Linux 쉘 종류
		![[Pasted image 20250716172454.png]]
		1. `Bourne Again Shell (Bash)`
			- 대부분의 Linux 배포판에서 기본 쉘
			- `Bash`에서 제공하는 주요 기능들
				- 스크립팅 기능을 갖춘 널리 사용되는 쉘
				- Tab completion feature (탭 완성 기능)을 제공함 (명령어 입력 중에 키보드의 탭 키를 누르면 가능한 일치를 기반으로 명령어를 자동으로 완성하거나 여러 완성 제안을 제공)
				- 모든 명령어의 History file과 logs를 유지하고 기록함 (`history`를 입력하여 모든 이전 명령어를 표시할 수도 있음)

		2. `Friendly Interactive Shell (Fish)`
			- 대부분의 Linux 배포판에서 기본으로 설치되어 있지 않음
			- 다른 쉘보다 user-friendliness에 더 중점을 둠
			- `Fish`에서 제공하는 주요 기능들
				- 초보자 사용자에게 적합한 매우 간단한 구문을 제공
				- `Bash`와 달리 작성한 명령어에 대한 자동 맞춤법 교정 기능이 있음
				- `Fish`를 사용하여 멋진 테마로 명령 프롬프트를 사용자 정의할 수 있음
				- Syntax highlighting feature은 명령어의 서로 다른 부분을 역할에 따라 색상으로 구분하여 명령어의 가독성을 향상시킴 (또한, 고유한 색상으로 오류를 발견하는 데 도움이 됨)
				- 스크립팅, 탭 완성, 명령 히스토리 기능도 제공

		3. `Z Shell (Zsh)`
			- 대부분의 Linux 배포판에서 기본으로 설치되어 있지 않음
			- 이전 쉘들의 기능을 결합한 현대적인 쉘로 간주됨
			- `Zsh`에서 제공하는 주요 기능들
				- Advanced tab completion 기능을 제공하며 writing scripts 기능도 있음
				- `Fish`와 마찬가지로 Auto spell correction for the commands 기능도 제공함
				- 광범위한 사용자 정의 기능을 제공하지만, 이로 인해 다른 쉘보다 느려질 수 있음
				- 탭 완성, 명령 히스토리 기능 및 여러 기타 기능들도 제공함
		
3. Shell Scripting and Components
	1. Shell Scripting란?
		- 셸 스크립트는 단순히 명령어들의 집합
		- 자주 쓰는 명령어들을 하나의 스크립트로 결합할 수 있음
		- 스크립팅은 작업을 자동화하는 데 도우밍 됨

	2. Create Script File
		- 셸에서 입력하는 다른 명령어들과 달리, 스크립트를 위해서는 먼저 Text editor를 사용하여 파일을 생성해야 함
		- 파일명은 반드시 `.sh` 확장자로 명명해야 함 (`bash` 스크립트의 기본 확장자)
			![[Pasted image 20250716173947.png]]

	3. `shebang`
		- 모든 스크립트는 `shebang`으로 시작해야 함
		- `shebang`은 스크립트 시작 부분에 추가되는 문자들의 조합
		- `#!`으로 시작하고, 그 뒤에 스크립트 실행 시 사용할 interpreter의 이름이 따름
			![[Pasted image 20250716174200.png]]

	4. Shell Components
		1. Variables
			- 변수는 내부에 값을 저장함
			- 스크립트에서 URL, file path 등과 같은 복잡한 값을 여러 번 사용해야 한다면, 매번 기억하고 반복적으로 작성하는 대신, 변수에 저장하고 필요한 곳에서 변수명을 사용할 수 있음
			- 작업을 완료하면 `ctrl + x`를 눌러 스크립트를 저장하고, `y`를 눌러 확인한 뒤 `enter`
				![[Pasted image 20250716174836.png]]

		2. Execution Permission to Script (실행 권한 부여)
			- 스크립트를 실행하려면 먼저 스크립트에 실행 권한이 있는지 확인해야 함
			- 스크립트에 권한 부여하기
				![[Pasted image 20250716175411.png]]
			- 스크립트에 실행 권한을 주었으므로, 스크립트명 앞에 `./`를 사용하여 실행함
			- `./` 사용하는 이유: 셸에게 현재 디렉터리에 있는 파일을 실행하라고 알려주는 것임 (만약 `./`를 정의하지 않으면, 셸은 PATH 환경 변수 (현재 디렉터리를 제외한 모든 디렉터리를 포함)에서 스크립트를 찾게 되고, 해당 디렉터리들에서 정의된 스크립트를 찾을 수 없어 오류 발생)
				![[Pasted image 20250716175701.png]]

		3. Loops
			- `~$ nano loop_script.sh`:  새 파일 생성
			- ![[Pasted image 20250716180253.png]]
			- `ctrl + x` -> `y` -> `enter`
			- `~$ chmod +x loop_script.sh`
			- `~$ ./loop_script.sh`
				![[Pasted image 20250716180423.png]]

		4. Conditional Statements (조건문)
			- 조건문은 스크립팅의 필수 부문
			- 권한이 특정 수준 이상의 높은 사람이 본인의 이름과 일치하면 비밀을 표시하는 조건문 생성하기
				1. `conditional_script.sh`라는 새 파일 생성
				2. 아래의 내용 입력후 `ctrl + x` -> `y` -> `enter`
					![[Pasted image 20250716180900.png]]
				3. 사용자 이름이 스크립트에 정의된 승인된 이름과 일치 / 불일치 할 때 결과
					![[Pasted image 20250716181035.png]]
					![[Pasted image 20250716181055.png]]

		5. Comments
			- `#`기호 사용

4. The Locker Script
	1. Requirement
		- 스크립트 실행 시, 사용자에게 이름, 회사명, PIN을 요청해야 함
		- 사용자가 옳은 정보를 입력하면 접근이 허용되고, 그렇지 않으면 접근 거부

	2. Script
		```shell
# 인터프리터 정의
#!/bin/bash 

# 변수 정의
username=""
companyname=""
pin=""

# 반복문 정의
for i in {1..3}; do
# 조건문 정의
        if [ "$i" -eq 1 ]; then
                echo "Enter your Username:"
                read username
        elif [ "$i" -eq 2 ]; then
                echo "Enter your Company name:"
                read companyname
        else
                echo "Enter your PIN:"
                read pin
        fi
done

# 사용자가 올바른 정보를 입력했는지 확인
if [ "$username" = "John" ] && [ "$companyname" = "Tryhackme" ] && [ "$pin" = "7385" ]; then
        echo "Authentication Successful. You can now access your locker, John."
else
        echo "Authentication Denied!!"
fi
```

	3. Script Execution
		![[Pasted image 20250716182245.png]]







































