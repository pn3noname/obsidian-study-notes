source: https://frontendmasters.com/courses/algorithms/bubble-sort/

# ==1. Bubble Sort==
## 1) 버블 정렬을 선택한 이유
- 일반적인 알고리즘 책에서 삽입 정렬로 시작하는 것과 달리, 버블 정렬부터 설명하는 이유
	- 삽입 정렬의 문제점: 카드 덱 예제가 이해하기 어려움
	- 버블 정렬의 장점:
		1. 시각적으로 이해하기 매우 쉬움
		2. 단 3줄의 코드로 구현 가능
		3. 극도로 간단한 알고리즘

## 2) 버블 정렬의 특징
- 매우 간단한 정렬 알고리즘으로 구현이 쉬움
- 제자리 정렬 (in-place sorting): 추가 메모리 공간을 거의 사용하지 않음
- 이진 탐색보다도 구현이 간단함
- 성능상의 한계
	- 불변 배열 (immutable array)에서 사용하면 성능이 매우 나빠짐
	- 역순으로 정렬된 배열의 경우 최악의 성능을 보임
	- 실제 개발에서는 거의 사용되지 않는 비효율적인 알고리즘

## ​3) 정렬된 배열의 정의
- 수학적으로 정렬된 배열의 정의:
	- 배열의 모든 i번째 위치에서 `x[i] ≤ x[i+1]`이 성립해야 함
	- 이 조건이 전체 배열에 대해 성립해야 정렬된 것

## 4) 버블 정렬 알고리즘 동작 원리
- 예시 배열: `[1, 3, 7, 4, 2]`
- 핵심 원리:
	- 0번째 위치부터 시작해서 배열 끝까지 진행
	- 각 위치에서 다음 요소와 비교
	- 현재 요소가 다음 요소보다 크면 위치를 교환
- 1회 반복 과정:
	1. 1과 3 비교 -> 교환 안함
	2. 3과 7 비교 -> 교환 안함
	3. 7과 4 비교 -> 7 > 4이므로 교환 -> `[1, 3, 4, 7, 2]`
	4. 7과 2 비교 -> 7 > 2이므로 교환 -> `[1, 3, 4, 2, 7]`
- 결과: 1회 반복 후 가장 큰 값 (7)이 마지막 위치에 배치됨
- 2회 반복 과정: 마지막 위치는 이미 정렬되었으므로 제외하고 진행
- 3회 반복 과정: 뒤의 두 위치는 제외하고 진행
- 이런 식으로 검사할 범위가 점점 줄어듦
- 한 개 요소만 남을 때까지 반복 (한 개 요소는 항상 정렬된 상태)
- 코드
```typescript
export default function bubble_sort(arr: number[]): void {
	for (let i = 0; i < arr.length; i++) {
		for (let j = 0; j < arr.length - 1 - i; j++) {
			if (arr[j] > arr[j + 1]) {
				const temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
}
```

## 5) 시간 복잡도 분석
- 반복 횟수:
	- 1회차: n번 비교
	- 2회차: n-1번 비교
	- 3회차: n-2번 비교
	- ...
	- 마지막: 1번 비교
- 가우스의 일화를 통한 설명:
	- 1부터 100까지 더하는 문제를 가우스가 10초 만에 해결
	- 방법: 1+100=101, 2+99=101, ..., 50+51=101
	- 총 50개의 101 -> 101x50 = 5050
	- 일반화: `n(n+1)/2`
- 시간 복잡도 계산:
	- 총 비교 횟수: `n + (n-1) + (n-2) + ... + 1 = n(n+1)/2`
	- 전개: `(n² + n)/2`
	- 상수 제거: n² + n
	- 최고차항만 고려: O(n²)
- n이 커질수록 n²항이 지배적이 되어 n항은 무시할 수 있게 됨
- 버블 정렬은 구현이 매우 간단하지만 O(n²)의 시간 복잡도를 가져 큰 데이터셋에는 비효율적인 알고리즘

# ==2. Linked List Data Structures==
## 1) 배열의 한계점
### JavaScript 배열의 특성
- JavaScript의 배열은 사실 진정한 배열이 아님
- `push()`, 삽입, 삭제 등이 가능하고 인덱스가 자동으로 조절됨
- 실제 배열 위에 추가적인 구조가 존재

### 전통적인 배열의 문제점
- 삭제: 실제로 삭제할 수 없고 0으로 만들 뿐
- 삽입: 실제 삽입이 불가능
- 크기 고정: 배열은 크기가 고정되어 있음

## 2) 연결 리스트란?
### 기본 개념
- 첫 번째 진짜 자료구조로 간주
- 노드 기반 자료구조 (Node-based data structure)
- 연결 리스트에는 index가 없음
- 각 노드는 데이터를 감싸는 컨테이너 역할

### 노드 구조
```typescript
type Node<T> = {
	value: T;       // 실제 데이터
	next?: Node<T>;
}
```

### 동작 원리
- 각 노드가 값과 다음 노드에 대한 참조를 가짐
- 체인처럼 연결된 구조
- 헤드 (head)부터 시작해서 순차적으로 접근

## 3) 단일 연결 리스트 vs 이중 연결 리스트
### 단일 연결 리스트 (Singly Linked List)
- 각 노드가 다음 노드만 참조
- A -> B -> C -> D
- 한 방향으로만 이동 가능
- 뒤로 돌아갈 수 없음

### 이중 연결 리스트 (Doubly Linked List)
- 각 노드가 이전 노드와 다음 노드 모두 참조
- A ⇄ B ⇄ C ⇄ D
- 양방향 이동 가능
- `previous`와 `next` 속성 보유

## 4) 연결 리스트의 주요 연산
### 삽입 (Insertion): O(1)
- A와 B 사이에 F를 삽입하는 경우:
	1. A의 next를 F로 설정
	2. F의 next를 B로 설정
	3. B의 previous를 F로 설정
	4. F의 previous를 A로 설정
- 시간 복잡도: O(1) - 상수 시간

### 삭제 (Deletion): O(1)
- C 노드를 삭제하는 경우( = C.prev & B.next = C.next):
	1. B의 next를 D로 설정 (C.next)
	2. D의 previous를 B로 설정 (C.previous)
	3. C의 next와 previous를 null로 설정 (C.prev = C.next = null)
	4. C의 값을 반환 (ret C.val)
- 시간 복잡도: O(1) - 상수 시간

## 5) 연결 리스트의 장점
### 효율적인 삽입 / 삭제
- 배열과 달리 요소를 이동시킬 필요 없음
- 링크만 조정하면 되므로 O(1) 시간
- 입력 크기와 무관하게 일정한 시간

### 동적 크기
- 필요에 따라 크기 조정 가능
- 메모리를 효율적으로 사용

## 6) 연결 리스트의 단점
### 인덱스 접근 불가
- 배열처럼 `arr[i]`로 직접 접근 불가
- n번째 요소에 접근하려면 처음부터 순차적으로 이동해야 함
- 접근 시간: O(n)

### 메모리 오버헤드
- 각 노드마다 포인터를 위한 추가 메모리 필요
- 힙 (heap) 메모리 사용으로 스택보다 비용 증가

### 7) 구현 시 주의사항
### 연산 순서의 중요성
- 링크를 끊기 전에 새로운 연결을 먼저 설정
- 잘못된 순서로 하면 노드에 접근할 수 없게 됨

### 경계 조건 처리
- null 체크, undefined 체크 필요
- 첫 번째나 마지막 노드 처리 시 특별한 주의

## 8) 핵심 개념 정리
- 연결 리스트는 메모리를 직접 할당하고 관리하는 첫 번째 자료구조로, 포인터를 통해 메모리를 순회하는 방식을 배울 수 있는 중요한 개념
- 배열의 고정된 한계를 극복하고 동적인 자료 관리를 가능하게 해주는 핵심적인 자료구조


> [!INFO]
> ### 연결 리스트의 삽입과 삭제의 시간 복잡도가 O(1)일 때의 중요한 전제 조건
> #### - 핵심 포인트: "어디에" 삽입 / 삭제 하는지가 중요함
> ##### 1. O(1)인 경우: 위치를 이미 알고 있을 때
> 	기존: A -> B -> C -> D
> 	
> 	B와 C 사이에 X를 삽입하고 싶은데, 이미 B 노드의 참조 (포인터)를 가지고 있다면:
> 	
> 	1. X.next = B.next (X가 C를 가리키게)
> 	2. B.next = X (B가 X를 가리키게)
> 	
> 	A -> B -> X -> C -> D
> - 왜 O(1)인가?
> 	- 포인터 2개만 바꾸면 끝
> 	- 데이터를 이동시킬 필요 없음
> 	- 노드를 찾아 헤매지 않음 (이미 위치를 알고 있으므로)
> ##### 2. O(n)인 경우: 위치를 찾아야 할 때
> 	"3번째 위치에 삽입해줘"라고 하면:
> 	
> 	1. head부터 시작해서 1 -> 2 -> 3 순차 탑색 (O(n))
> 	2. 찾은 후 삽입 (O(1))
> 	3. 총 시간 복잡도: O(n)
> 	
> ##### 3. 배열과의 비교
> 	배열의 중간 삽입:
> 	[A, B, C, D]에서 B 뒤에 X 삽입
> 	
> 	4. C와 D를 한 칸씩 뒤로 밀어야 함
> 	5. [A, B, _ , C, D] -> [A, B, X, C, D]
> 	6. 시간 복잡도: O(n) (데이터 이동 때문에)
> 	
> 	연결 리스트의 삽입 (위치를 안다면):
> 	포인터만 바꾸면 끝 -> O(1)
> 	
> ##### 실제로는 ...
> 	대부분의 경우 "어디에 삽입할지" 먼저 찾아야 하므로:
> 	- 찾기: O(n)
> 	- 삽입: O(1)
> 	- 전체: O(n)
> 	하지만 head나 tail에 삽입하거나, 이미 노드 찹조를 가지고 있는 경우에는 O(1)


# ==3. Linked List Complexity==
## 1) 기본 연산들
- 만약 다섯 번째 값을 요청한다면, 이런 구조에서는 다섯 번째 값을 바로 가져올 방법이 없음
- 문자 그대로 0부터 5까지의 루프를 작성해야 하고, `current = current.next`와 같은 방식으로 올바른 값에 도달할 때까지 순회해야 함
- 중요한 점
	- 포함하는 노드 (containing node) 자체를 반환해서는 안 됨
	- 그럴 경우, 내부 구조가 노출되어 누군가에게 next와 previous 값을 조작할 수 있고, 그러면 전체 리스트가 망가짐
	- 이는 실용적인 구현 관점에서 중요함
	- 포함하는 노드는 우리는 위한 추상화일 뿐, 외부 세계를 위한 것이 아님

## 2) 시간 복잡도 분석
### 헤드 (Head)와 테일 (Tail) 접근
- 