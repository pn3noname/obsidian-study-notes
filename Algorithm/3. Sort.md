source: https://frontendmasters.com/courses/algorithms/bubble-sort/

# ==1. Bubble Sort==
## 1) 버블 정렬을 선택한 이유
- 일반적인 알고리즘 책에서 삽입 정렬로 시작하는 것과 달리, 버블 정렬부터 설명하는 이유
	- 삽입 정렬의 문제점: 카드 덱 예제가 이해하기 어려움
	- 버블 정렬의 장점:
		1. 시각적으로 이해하기 매우 쉬움
		2. 단 3줄의 코드로 구현 가능
		3. 극도로 간단한 알고리즘

## 2) 버블 정렬의 특징
- 매우 간단한 정렬 알고리즘으로 구현이 쉬움
- 제자리 정렬 (in-place sorting): 추가 메모리 공간을 거의 사용하지 않음
- 이진 탐색보다도 구현이 간단함
- 성능상의 한계
	- 불변 배열 (immutable array)에서 사용하면 성능이 매우 나빠짐
	- 역순으로 정렬된 배열의 경우 최악의 성능을 보임
	- 실제 개발에서는 거의 사용되지 않는 비효율적인 알고리즘

## ​3) 정렬된 배열의 정의
- 수학적으로 정렬된 배열의 정의:
	- 배열의 모든 i번째 위치에서 `x[i] ≤ x[i+1]`이 성립해야 함
	- 이 조건이 전체 배열에 대해 성립해야 정렬된 것

## 4) 버블 정렬 알고리즘 동작 원리
- 예시 배열: `[1, 3, 7, 4, 2]`
- 핵심 원리:
	- 0번째 위치부터 시작해서 배열 끝까지 진행
	- 각 위치에서 다음 요소와 비교
	- 현재 요소가 다음 요소보다 크면 위치를 교환
- 1회 반복 과정:
	1. 1과 3 비교 -> 교환 안함
	2. 3과 7 비교 -> 교환 안함
	3. 7과 4 비교 -> 7 > 4이므로 교환 -> `[1, 3, 4, 7, 2]`
	4. 7과 2 비교 -> 7 > 2이므로 교환 -> `[1, 3, 4, 2, 7]`
- 결과: 1회 반복 후 가장 큰 값 (7)이 마지막 위치에 배치됨
- 2회 반복 과정: 마지막 위치는 이미 정렬되었으므로 제외하고 진행
- 3회 반복 과정: 뒤의 두 위치는 제외하고 진행
- 이런 식으로 검사할 범위가 점점 줄어듦
- 한 개 요소만 남을 때까지 반복 (한 개 요소는 항상 정렬된 상태)
- 코드
```typescript
export default function bubble_sort(arr: number[]): void {
	for (let i = 0; i < arr.length; i++) {
		for (let j = 0; j < arr.length - 1 - i; j++) {
			if (arr[j] > arr[j + 1]) {
				const temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
}
```

## 5) 시간 복잡도 분석
- 반복 횟수:
	- 1회차: n번 비교
	- 2회차: n-1번 비교
	- 3회차: n-2번 비교
	- ...
	- 마지막: 1번 비교
- 가우스의 일화를 통한 설명:
	- 1부터 100까지 더하는 문제를 가우스가 10초 만에 해결
	- 방법: 1+100=101, 2+99=101, ..., 50+51=101
	- 총 50개의 101 -> 101x50 = 5050
	- 일반화: `n(n+1)/2`
- 시간 복잡도 계산:
	- 총 비교 횟수: `n + (n-1) + (n-2) + ... + 1 = n(n+1)/2`
	- 전개: `(n² + n)/2`
	- 상수 제거: n² + n
	- 최고차항만 고려: O(n²)
- n이 커질수록 n²항이 지배적이 되어 n항은 무시할 수 있게 됨
- 버블 정렬은 구현이 매우 간단하지만 O(n²)의 시간 복잡도를 가져 큰 데이터셋에는 비효율적인 알고리즘

# ==2. Linked List Data Structures==
## 1) 배열의 한계점
### JavaScript 배열의 특성
- JavaScript의 배열은 사실 진정한 배열이 아님
- `push()`, 삽입, 삭제 등이 가능하고 인덱스가 자동으로 조절됨
- 실제 배열 위에 추가적인 구조가 존재

### 전통적인 배열의 문제점
- 삭제: 실제로 삭제할 수 없고 0으로 만들 뿐
- 삽입: 실제 삽입이 불가능
- 크기 고정: 배열은 크기가 고정되어 있음

## 2) 연결 리스트란?
### 기본 개념
- 첫 번째 진짜 자료구조로 간주
- 노드 기반 자료구조 (Node-based data structure)
- 각 노드는 데이터를 감싸는 컨테이너 역할

### 노드 구조
```typescript
type Node<T> = {
	value: T;       // 실제 데이터
	next?: Node<T>;
}
```

### 동작 원리
- 각 노드가 값과 다음 노드에 대한 참조를 가짐
- 체인처럼 연결된 구조
- 헤드 (head)부터 시작해서 순차적으로 접근

## 3) 단일 연결 리스트 vs 이중 연결 리스트
### 단일 연결 리스트 (Singly Linked List)
- 각 노드가 다음 노드만 참조
- A -> B -> C -> D
- 한 방향으로만 이동 가능
- 뒤로 돌아갈 수 없음

### 이중 연결 리스트 (Doubly Linked List)
- 각 노드가 이전 노드와 다음 노드 모두 참조
- A ⇄ B ⇄ C ⇄ D
- 양방향 이동 가능
- `previous`와 `next` 속성 보유

## 4) 연결 리스트의 주요 연산
### 삽입 (Insertion): O(1)
- A와 B 사이에 F를 삽입하는 경우:
	1. A의 next를 F로 설정
	2. F의 next를 B로 설정
	3. B의 previous를 F로 설정
	4. F의 previous를 A로 설정
- 시간 복잡도: O(1) - 상수 시간

### 삭제 (Deletion): O(1)
- C 노드를 삭제하는 경우:
	1. B의 next를 D로 설정 (C.next)
	2. D의 previous를 B로 설정 (C.previous)
	3. C의 next와 previous를 null로 설정
	4. C의 값을 반환
- 시간 복잡도: O(1) - 상수 시간

## 5) 연결 리스트의 장점
### 효율적인 삽입 / 삭제
- 배열과 달리 요소를 이동시킬 필요 없음
- 링크만 조정하면 되므로 O(1) 시간
- 입력 크기와 무관하게 일정한 시간

### 동적 크기
- 필요에 따라 크기 조정 가능
- 메모리를 효율적으로 사용

## 6) 연결 리스트의 단점
### 인덱스 접근 불가
- 배열처럼 `arr[i]`로 직접 접근 불가
- n번째 요소에 접근하려면 처음부터 순차적으로 이동해야 함
- 접근 시간: O(n)

### 메모리 오버헤드
- 각 노드마다 포인터를 위한 추가 메모리 필요
- 