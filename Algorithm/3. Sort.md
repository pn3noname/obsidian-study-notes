source: https://frontendmasters.com/courses/algorithms/bubble-sort/

# ==1. Bubble Sort==
## 1) 버블 정렬을 선택한 이유
- 일반적인 알고리즘 책에서 삽입 정렬로 시작하는 것과 달리, 버블 정렬부터 설명하는 이유
	- 삽입 정렬의 문제점: 카드 덱 예제가 이해하기 어려움
	- 버블 정렬의 장점:
		1. 시각적으로 이해하기 매우 쉬움
		2. 단 3줄의 코드로 구현 가능
		3. 극도로 간단한 알고리즘

## 2) 정렬된 배열의 정의
- 수학적으로 정렬된 배열의 정의:
	- 배열의 모든 i번째 위치에서 `x[i] ≤ x[i+1]`이 성립해야 함
	- 이 조건이 전체 배열에 대해 성립해야 정렬된 것

## 3) 버블 정렬 알고리즘 동작 원리
- 예시 배열: `[1, 3, 7, 4, 2]`
- 핵심 원리:
	- 0번째 위치부터 시작해서 배열 끝까지 진행
	- 각 위치에서 다음 요소와 비교
	- 현재 요소가 다음 요소보다 크면 위치를 교환
- 1회 반복 과정:
	1. 1과 3 비교 -> 교환 안함
	2. 3과 7 비교 -> 교환 안함
	3. 7과 4 비교 -> 7 > 4이므로 교환 -> `[1, 3, 4, 7, 2]`
	4. 7과 2 비교 -> 7 > 2이므로 교환 -> `[1, 3, 4, 2, 7]`
- 결과: 1회 반복 후 가장 큰 값 (7)이 마지막 위치에 배치됨
- 2회 반복 과정: 마지막 위치는 이미 정렬되었으므로 제외하고 진행
- 3회 반복 과정: 뒤의 두 위치는 제외하고 진행
- 이런 식으로 검사할 범위가 점점 줄어듦
- 한 개 요소만 남을 때까지 반복 (한 개 요소는 항상 정렬된 상태)

## 4) 시간 복잡도 분석
- 반복 횟수:
	- 1회차: n번 비교
	- 2회차: n-1번 비교
	- 3회차: n-2번 비교
	- ...
	- 마지막: 1번 비교
- 가우스의 일화를 통한 설명:
	- 1부터 100까지 더하는 문제를 가우스가 10초 만에 해결
	- 방법: 1+100=101, 2+99=101, ..., 50+51=101
	- 총 50개의 101 -> 101x50 = 5050
	- 일반화: `n(n+1)/2`
- 시간 복잡도 계산:
	- 총 비교 횟수: `n + (n-1) + (n-2) + ... + 1 = n(n+1)/2`
	- 전개: `(n² + n)/2`
	- 상수 제거: n² + n
	- 최고차항만 고려: O(n²)
- n이 커질수록 n²항이 지배적이 되어 n항은 무시할 수 있게 됨
- 버블 정렬은 구현이 매우 간단하지만 O(n²)의 시간 복잡도를 가져 큰 데이터셋에는 비효율적인 알고리즘